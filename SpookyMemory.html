<!-- Powered by the JumpStart Game Engine -->
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Spooky Memory</title>

		<!-- AltspaceVR SDK Core Includes -->
		<script src="http://sdk.altvr.com/libs/three.js/r71/build/three.min.js"></script>
		<script src="http://sdk.altvr.com/libs/three.js/r71/examples/js/loaders/OBJMTLLoader.js"></script>
		<script src="http://sdk.altvr.com/libs/three.js/r71/examples/js/loaders/MTLLoader.js"></script>
		<script src="http://sdk.altvr.com/libs/altspace.js/latest/altspace.min.js"></script>

		<!-- JumpStart SDK Additional Includes -->
		<script src="FirebaseSync.js"></script>
		<script src="AltOBJMTLLoader.js"></script>

		<!-- JumpStart Styles -->
		<link rel="stylesheet" type="text/css" href="myStyle.css">
	</head>

	<body>

		<!-- JumpStart SDK Core Include -->
		<script src="JumpStart.js"></script>

		<!-- Window-Level Event Callbacks -->
		<script>
			JumpStart.setOptions({"showCrosshair": false});

			var g_deck = null;
			var g_deckRig = null;
			var g_deckRigVerts = null;
			var g_gameState = 0;

			var g_tossTarget = null;
			var g_lastTossedIndex = 0;
			var g_cardMap = [5, 8, 3, 0, 6, 9, 4, 2, 1, 10, 7];

			function onReady()
			{
				// Do nothing if we are not in an enclosure yet.
				if( JumpStart.personalBrowser )
				{
					var loadingRingElem = document.getElementById("loadingRing");
					if( loadingRingElem )
					{
						loadingRingElem.parentNode.removeChild(loadingRingElem);
					}

					var loadingLogoElem = document.getElementById("loadingLogo");
					if( loadingLogoElem )
					{
						loadingLogoElem.src = "misc/beamnow.png";
					}

					JumpStart.showLoadingMsg("Loading complete.<br /><br /><font style='color: #00ff00; font-size: 30px; background-color: rgba(0, 0, 0, 0.5); padding: 10px; border-radius: 10px;'>Beam this app to an enclosure to begin!</font>");
					return;
				}

				// JumpStart can only use models IT loads
				var myModels = [
					"models/SpookyMemory/card0.obj",
					"models/SpookyMemory/card1.obj",
					"models/SpookyMemory/card2.obj",
					"models/SpookyMemory/card3.obj",
					"models/SpookyMemory/card4.obj",
					"models/SpookyMemory/deck.obj",
					"models/SpookyMemory/deckrig.obj",
					"models/SpookyMemory/pixel1.obj"
				];

				JumpStart.loadModels(myModels).then(function() {

					// Spawn the deck
					g_deck = JumpStart.spawnInstance("models/SpookyMemory/deck.obj");
					g_deck.position.copy(g_worldOffset);
					g_deck.position.x -= 100.0;
					g_deck.scale.multiplyScalar(0.5);

					// Load the deck rig
					g_deckRig = JumpStart.spawnInstance("models/SpookyMemory/deckrig.obj", {parent: g_deck});
					g_deckRig.JumpStart.blocksLOS = false;
					g_deckRig.scale.multiplyScalar(g_deck.scale.x);

					g_deckRigVerts = g_deckRig.children[g_deckRig.children.length-1].geometry.vertices;

					// Adjust scale of all the verts
					var x;
					for( x in g_deckRigVerts )
					{
						g_deckRigVerts[x].multiplyScalar(g_deck.scale.x);
					}

					var mat = null;
					for( mesh in g_deckRig.children )
					{
						mat = g_deckRig.children[mesh].material;

						if( !mat )
							continue;

						mat.visible = false;
						mat.transparent = true;
					}

					setTimeout(function()
					{
						tossCard();
					}, 1000);

			/* CURSOR RAY VISUALIZATION
			var marker = JumpStart.spawnInstance("models/SpookyMemory/pixel1.obj");
			marker.JumpStart.blocksLOS = false;
			marker.scale.set(1, 1, 1);

			marker.JumpStart.onTick = function()
			{
				if( !g_lookHit )
					return;

				marker.position.copy(g_localUser.lookOrigin);
				marker.translateY(2.0);
				marker.lookAt(g_lookHit.scaledPoint);
				marker.scale.z = g_localUser.lookOrigin.distanceTo(g_lookHit.scaledPoint);
			};
			*/

					// Now start the simulation
					JumpStart.run();
				});
			}
		</script>

		<!-- Custom Object-Level Event Callbacks -->
		<script>
			function highlightOnObject()
			{
				var myColor = new THREE.Color(1.5, 1.5, 1.5);
				this.JumpStart.setTint(myColor);
			}

			function highlightOffObject()
			{
				var myColor = new THREE.Color(1.0, 1.0, 1.0);
				this.JumpStart.setTint(myColor);
			}

			function tossCard()
			{
				g_lastTossedIndex++;

				if( g_lastTossedIndex > g_cardMap.length-2 )
				{
					console.log("Game state 1xx");
					g_gameState = 1;
					return;
				}

				// Spawn a card
				var randoCard = Math.floor((Math.random() * 5) + 1) - 1;
				var card = JumpStart.spawnInstance("models/SpookyMemory/card" + randoCard + ".obj");
				card.JumpStart.blocksLOS = false;
				card.JumpStart.onCursorEnter["highlightOnObject"] = highlightOnObject;
				card.JumpStart.onCursorLeave["highlightOffObject"] = highlightOffObject;

				card.position.copy(g_deck.position);
				card.rotation.copy(g_deck.rotation);
				card.rotateY(Math.PI);
				card.scale.copy(g_deck.scale);
				card.userData.isTossing = true;

				var targetPos = g_deckRigVerts[g_cardMap[0]];
				card.translateX(targetPos.x);
				card.translateY(targetPos.y);
				card.translateZ(targetPos.z);

				if( !g_tossTarget )
				{
					g_tossTarget = JumpStart.spawnInstance("models/SpookyMemory/pixel1.obj");
					g_tossTarget.scale.set(0.0001, 0.0001, 0.0001);
				}

				g_tossTarget.position.copy(g_deck.position);
				g_tossTarget.rotation.copy(g_deck.rotation);

				var targetPos = g_deckRigVerts[g_cardMap[g_lastTossedIndex]];
				g_tossTarget.translateX(targetPos.x);
				g_tossTarget.translateY(targetPos.y);
				g_tossTarget.translateZ(targetPos.z);
			/*
				var tossVec = new THREE.Vector3().copy(g_tossTarget.position);
				tossVec.sub(card.position);

				tossVec.multiplyScalar(0.033);

				if( !JumpStart.webMode )
					tossVec.multiplyScalar(0.8);


				var yIntensity = tossVec.length() / 1.0;
				if( yIntensity < 2.0 )
					yIntensity = 2.0;

				tossVec.y = yIntensity;

				card.JumpStart.applyForce(tossVec);
				card.JumpStart.freefallRot.x = 0;
				card.JumpStart.freefallRot.z = 0;
			*/

				// LERP the position
			//	g_tossTarget.position.copy(g_deck.position);
			//	g_tossTarget.rotation.copy(g_deck.rotation);

			//	var targetPos = g_deckRigVerts[g_cardMap[g_cardMap.length-1]];
			//	g_tossTarget.translateX(targetPos.x);
			//	g_tossTarget.translateY(targetPos.y);
			//	g_tossTarget.translateZ(targetPos.z);

				var posOriginal = new THREE.Vector3().copy(card.position);
			//	posOriginal.y = g_tossTarget.position.y;

				var dist = g_tossTarget.position.distanceTo(posOriginal);

				card.userData.targetPos = new THREE.Vector3().copy(g_tossTarget.position);
				card.userData.targetPosOriginal = posOriginal;
				card.userData.targetPosLerp = 0.0;
				card.userData.targetPosLerpTime = dist / (50 + (0.9 * dist));
				card.userData.targetPosCallback = function()
				{
					this.userData.isTossing = false;
					tossCard();

					card.userData.targetPosCallback = null;
				};

				// LERP the rotation
				card.userData.targetRot = new THREE.Vector3(0, 2.0 * Math.PI, 0);
				card.userData.targetRotOriginal = new THREE.Vector3().copy(card.rotation);
				card.userData.targetRotLerp = 0.0;
				card.userData.targetRotLerpTime = card.userData.targetPosLerpTime;

				card.JumpStart.blocksLOS = true;
				card.JumpStart.onCursorDown = function()
				{
					if( g_gameState !== 1 )
						return;

					console.log("Game state 2");
					g_gameState = 2;

					// LERP the scale
					this.userData.targetScale = new THREE.Vector3(1.5, 1.5, 1.5);
					this.userData.targetScaleOriginal = new THREE.Vector3().copy(this.scale);
					this.userData.targetScaleLerp = 0.0;
					this.userData.targetScaleLerpTime = 1.0;

					this.userData.targetScaleAnim = [
						{
							targetScale: new THREE.Vector3().set(1.5, 1.5, 1.5),
							targetScaleOriginal: null,
							targetScaleLerp: 0.0,
							targetScaleLerpTime: 2.0
						},
						{
							targetScale: new THREE.Vector3().copy(this.scale),
							targetScaleOriginal: null,
							targetScaleLerp: 0.0,
							targetScaleLerpTime: 1.0
						}
					];

					// LERP the position
					g_tossTarget.position.copy(g_deck.position);
					g_tossTarget.rotation.copy(g_deck.rotation);

					var targetPos = g_deckRigVerts[g_cardMap[g_cardMap.length-1]];
					g_tossTarget.translateX(targetPos.x);
					g_tossTarget.translateY(targetPos.y);
					g_tossTarget.translateZ(targetPos.z);

					g_tossTarget.up = new THREE.Vector3(0, 1, 0);
					g_tossTarget.lookAt(g_localUser.lookOrigin);

					this.userData.targetPos = new THREE.Vector3().copy(g_tossTarget.position);
					this.userData.targetPosOriginal = new THREE.Vector3().copy(this.position);
					this.userData.targetPosLerp = 0.0;
					this.userData.targetPosLerpTime = 1.0;

					this.userData.targetPosAnim = [
						{
							targetPos: new THREE.Vector3().copy(g_tossTarget.position),
							targetPosOriginal: null,
							targetPosLerp: 0.0,
							targetPosLerpTime: 2.0
						},
						{
							targetPos: new THREE.Vector3().copy(this.position),
							targetPosOriginal: null,
							targetPosLerp: 0.0,
							targetPosLerpTime: 1.0,
							targetPosCallback: function()
							{
								console.log("Game state 1");
								g_gameState = 1;
								this.targetPosCallback = null;
							}
						}
					];

					// LERP the rotation
					//this.userData.targetRot = new THREE.Vector3().copy(g_deck.rotation);
					g_tossTarget.rotateX(Math.PI / 2.0);
					g_tossTarget.rotateZ(Math.PI);
					this.userData.targetRot = new THREE.Vector3().copy(g_tossTarget.rotation);
					//this.userData.targetRot.x += Math.PI / 2.0
			//		this.userData.targetRot.z += Math.PI;

					this.userData.targetRotOriginal = new THREE.Vector3().copy(this.rotation);
					this.userData.targetRotLerp = 0.0;
					this.userData.targetRotLerpTime = 1.0;

					// Setup the rest of the animation
					this.userData.targetRotAnim = [
						{
							targetRot: new THREE.Vector3().copy(this.userData.targetRot),
							targetRotOriginal: null,
							targetRotLerp: 0.0,
							targetRotLerpTime: 2.0
						},
						{
							targetRot: new THREE.Vector3().copy(this.rotation).add(new THREE.Vector3(0, 0, Math.PI)),
							targetRotOriginal: null,
							targetRotLerp: 0.0,
							targetRotLerpTime: 1.0
						}
					];
				};

				card.JumpStart.onTick = function()
				{
					/*
					if( this.position.y <= g_worldOffset.y && this.JumpStart.physicsState !== 0 )
					{
						this.position.y = g_worldOffset.y;
						this.JumpStart.makeStatic();
			*/


			//			tossCard();
			//		}

					doScaleLerp.call(this);
					doRotationLerp.call(this);

					var oldY = null;
					if( this.userData.hasOwnProperty("targetPosLerp") && this.userData.isTossing )
						oldY = this.position.y;

					doPositionLerp.call(this);

					if( oldY )
					{
						var scalar = Math.abs(0.5 - this.userData.targetPosLerp);
						var yPos = this.position.y;

						if( this.userData.targetPosLerp <= 0.5 )
						{
							yPos = oldY + (700.0 * g_deltaTime * scalar);
						}
						else if( this.userData.targetPosLerp > 0.5 && this.userData.targetPosLerp < 1.0 )
						{
							yPos = oldY - (700.0 * g_deltaTime * scalar);
						}

						if( yPos < this.userData.targetPos.y )
							this.position.y = this.userData.targetPos.y;
						else
							this.position.y = yPos;
					}
				};
			}

			function doScaleLerp()
			{
				if( this.userData.hasOwnProperty("targetScaleLerp") && this.userData.targetScaleLerp < 1.0 )
				{
					this.userData.targetScaleLerp += (1.0/this.userData.targetScaleLerpTime) * g_deltaTime;

					var justFinished = false;
					if( this.userData.targetScaleLerp >= 1.0 )
					{
						this.userData.targetScaleLerp = 1.0;
						justFinished = true;
					}

					this.scale.lerpVectors(this.userData.targetScaleOriginal, this.userData.targetScale, this.userData.targetScaleLerp);

					if( justFinished )
					{
						if( this.userData.hasOwnProperty("targetScaleAnim") && this.userData.targetScaleAnim.length > 0 )
						{
							var nextTarget = this.userData.targetScaleAnim.shift();
							if( !nextTarget.targetScaleOriginal )
								nextTarget.targetScaleOriginal = new THREE.Vector3().copy(this.scale);

							// Set our new targets.
							this.userData.targetScale.copy(nextTarget.targetScale);
							this.userData.targetScaleOriginal.copy(nextTarget.targetScaleOriginal);
							this.userData.targetScaleLerp = nextTarget.targetScaleLerp;
							this.userData.targetScaleLerpTime = nextTarget.targetScaleLerpTime;
						}
					}
				}
			}

			function doPositionLerp()
			{
				if( this.userData.hasOwnProperty("targetPosLerp") && this.userData.targetPosLerp < 1.0 )
				{
					this.userData.targetPosLerp += (1.0/this.userData.targetPosLerpTime) * g_deltaTime;

					var justFinished = false;
					if( this.userData.targetPosLerp >= 1.0 )
					{
						this.userData.targetPosLerp = 1.0;
						justFinished = true;
					}

					this.position.lerpVectors(this.userData.targetPosOriginal, this.userData.targetPos, this.userData.targetPosLerp);

					if( justFinished )
					{
						if( typeof this.userData.targetPosCallback === "function" )
							this.userData.targetPosCallback.call(this);

						this.userData.targetPosCallback = null;

						if( this.userData.hasOwnProperty("targetPosAnim") && this.userData.targetPosAnim.length > 0 )
						{
							var nextTarget = this.userData.targetPosAnim.shift();
							if( !nextTarget.targetPosOriginal )
								nextTarget.targetPosOriginal = new THREE.Vector3().copy(this.position);

							// Set our new targets.
							this.userData.targetPos.copy(nextTarget.targetPos);
							this.userData.targetPosOriginal.copy(nextTarget.targetPosOriginal);
							this.userData.targetPosLerp = nextTarget.targetPosLerp;
							this.userData.targetPosLerpTime = nextTarget.targetPosLerpTime;
							if( typeof nextTarget.targetPosCallback === "function" )
								this.userData.targetPosCallback = nextTarget.targetPosCallback;
						}
					}
				}
			}

			function doRotationLerp()
			{
				if( this.userData.hasOwnProperty("targetRotLerp") && this.userData.targetRotLerp < 1.0 )
				{
					this.userData.targetRotLerp += (1.0/this.userData.targetRotLerpTime) * g_deltaTime;

					var justFinished = false;
					if( this.userData.targetRotLerp >= 1.0 )
					{
						this.userData.targetRotLerp = 1.0;
						justFinished = true;
					}

					var myQuaternionA = new THREE.Quaternion().setFromEuler(new THREE.Euler().setFromVector3(this.userData.targetRotOriginal, 'XYZ'));
					var myQuaternionB = new THREE.Quaternion().setFromEuler(new THREE.Euler().setFromVector3(this.userData.targetRot, 'XYZ'));

					myQuaternionA.slerp(myQuaternionB, this.userData.targetRotLerp);
					this.quaternion.copy(myQuaternionA);
			//		this.rotation.lerpVectors(this.userData.targetRotOriginal, this.userData.targetRot, this.userData.targetRotLerp);

					if( justFinished )
					{
						if( this.userData.hasOwnProperty("targetRotAnim") && this.userData.targetRotAnim.length > 0 )
						{
							var nextTarget = this.userData.targetRotAnim.shift();
							if( !nextTarget.targetRotOriginal )
								nextTarget.targetRotOriginal = new THREE.Vector3().copy(this.rotation);

							// Set our new targets.
							this.userData.targetRot.copy(nextTarget.targetRot);
							this.userData.targetRotOriginal.copy(nextTarget.targetRotOriginal);
							this.userData.targetRotLerp = nextTarget.targetRotLerp;
							this.userData.targetRotLerpTime = nextTarget.targetRotLerpTime;
						}
					}
				}
			}
		</script>
	</body>
</html>