<!-- Powered by the JumpStart Game Engine -->
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Line Racers</title>

		<!-- AltspaceVR SDK Core Includes -->
		<!--<script src="http://sdk.altvr.com/libs/three.js/r71/build/three.min.js"></script>-->
		<script src="http://sdk.altvr.com/libs/three.js/r73/build/three.min.js"></script>
		<script src="http://sdk.altvr.com/libs/three.js/r71/examples/js/loaders/OBJMTLLoader.js"></script>
		<script src="http://sdk.altvr.com/libs/three.js/r71/examples/js/loaders/MTLLoader.js"></script>
		<script src="http://sdk.altvr.com/libs/altspace.js/latest/altspace.min.js"></script>

		<script src="http://sdk.altvr.com/libs/three.js/r73/examples/js/geometries/TextGeometry.js"></script>
		<script src="http://sdk.altvr.com/libs/three.js/r73/examples/js/utils/FontUtils.js"></script>
		<script src="http://sdk.altvr.com/libs/three.js/r73/examples/fonts/helvetiker_regular.typeface.js"></script>

		<!-- JumpStart SDK Additional Includes -->
		<script src="FirebaseSync.js"></script>
		<script src="AltOBJMTLLoader.js"></script>

		<!-- JumpStart Styles -->
		<link rel="stylesheet" type="text/css" href="myStyle.css">
	</head>

	<body>

		<style>
			#highscores
			{
				font-family: Arial;
				font-size: 40px;
				font-weight: bold;
			}

			#highscores td
			{
				padding-left: 20px;
				padding-right: 20px;
			}
		</style>

		<!-- JumpStart SDK Core Include -->
		<script src="JumpStart.js"></script>

		<div style="position: absolute; top: 0; left: 0; right: 0;">
		<center>
			<br /><br /><br /><br />
			<div><table id="highscores"></table></div>
		</center>
		</div>

		<div id="attractImageParent" style="width: 100%; top: 250px; position: fixed; display: none;">
			<center>
				<img id="attractImage" src="misc/lineracers.jpg" style="width: 60%; display: block;" />
			</center>
		</div>

		<!-- Window-Level Event Callbacks -->
		<script>
			var myOptions =
			{
				"titleImageURL": "misc/lineracerstitle.png",
				"legacyLoader": false,
				"worldScale": 1.3,
				"scaleWithEnclosure": true,
				"showCrosshair": false,
				"showCursorPlanes": false,
				"camera":
				{
					"lookAtOrigin": true,
					"position": new THREE.Vector3(20.0, 70.0, 300.0),
					"translation": new THREE.Vector3(0.0, 20.0, 50.0)
				},
				"firebase":
				{
					"rootUrl": "https://lineracers.firebaseio.com/",
					"appId": "lineracers",
					"suppressPersonalBrowser": true
				}
			};

			JumpStart.setOptions(myOptions);

			// Window-level callback for onPrecache event
			function onPrecache()
			{
//				var allDataRef = JumpStart.firebaseSync.firebaseRoot;
//				allDataRef.remove();
//				return;

//				if( window.innerDepth === 300 ) //|| window.innerDepth == 1024 )
//					document.getElementById("attractImageParent").style.top = "170px";

				if( JumpStart.personalBrowser || !JumpStart.requestedRoomId )
				{
					JumpStart.doneCaching();
					return;
				}

				var myModels = [
					"models/LineRacers/arrow.obj",
					"models/LineRacers/dont.obj",
					"models/LineRacers/crashtext.obj",
					"models/LineRacers/star.obj",
					"models/LineRacers/gold.obj",
					"models/LineRacers/r.obj",
					"models/LineRacers/a.obj",
					"models/LineRacers/c.obj",
					"models/LineRacers/e.obj",
					"models/LineRacers/carstand.obj",
					"models/LineRacers/carstand_offsets.obj",
					"models/LineRacers/car_offsets.obj",
					"models/LineRacers/explosion.obj",
					"models/LineRacers/rearright.obj",
					"models/LineRacers/rearleft.obj",
					"models/LineRacers/frontright.obj",
					"models/LineRacers/frontleft.obj",
					"models/LineRacers/dead.obj",
					"models/LineRacers/car.obj",
					"models/LineRacers/pixel.obj",
					"models/LineRacers/driver.obj",
					"models/LineRacers/body.obj",

					"models/LineRacers/rearright1.obj",
					"models/LineRacers/rearleft1.obj",
					"models/LineRacers/frontright1.obj",
					"models/LineRacers/frontleft1.obj",
					"models/LineRacers/dead1.obj",
					"models/LineRacers/car1.obj",
					"models/LineRacers/pixel1.obj",
					"models/LineRacers/driver1.obj",
					"models/LineRacers/body1.obj",

					"models/LineRacers/rearright2.obj",
					"models/LineRacers/rearleft2.obj",
					"models/LineRacers/frontright2.obj",
					"models/LineRacers/frontleft2.obj",
					"models/LineRacers/dead2.obj",
					"models/LineRacers/car2.obj",
					"models/LineRacers/pixel2.obj",
					"models/LineRacers/driver2.obj",
					"models/LineRacers/body2.obj"
				];

				JumpStart.precacheSound("sounds/LineRacers/trumpet");
				JumpStart.precacheSound("sounds/LineRacers/crash");
				JumpStart.precacheSound("sounds/LineRacers/ching");
				JumpStart.precacheSound("sounds/LineRacers/carstart");
				JumpStart.precacheSound("sounds/LineRacers/cashout");
				JumpStart.precacheSound("sounds/LineRacers/explosion");
				JumpStart.precacheSound("sounds/LineRacers/idle");
				JumpStart.precacheSound("sounds/LineRacers/accelerate");

				JumpStart.loadModels(myModels).then(function() {
					JumpStart.doneCaching();
				});
			}

			function onCursorDown()
			{
				if( startButton && (!startButton.userData.hasOwnProperty("hidden") || !startButton.userData.hidden) )
					spawnCar.call(startButton);
				else if( g_myCar && g_myCar.userData.boost === 0 )
				{
					g_myCar.userData.boost = 2.0;
					JumpStart.playSound("sounds/LineRacers/accelerate", 0.03, false);
				}
			}

			var g_cars = new Array();
			var g_starGlobalOffsetCount = 0;
			var g_starSpot = 0;
			var g_starRotOffset = 0;
			var g_stars = new Array();
			var g_myCar = null;
			var g_arrow = null;
			var g_attract = document.body;
			var g_highScores = null;
			var g_crash = null;
			var g_crashText = null;
//			var dead = null;

			var chingLoop = null;
			var engineLoop = null;
			var startButton = null;

			function onReady()
			{
				/*
				var elem = document.createElement("div");
				elem.style.cssText = "position: absolute; top: 0; left: 0; right: 0; font-size: 50px; font-weight: 900; color: red;";
				elem.innerHTML = JumpStart.enclosure.innerWidth;
				document.body.appendChild(elem);
				*/

				// Do nothing if we are not in an enclosure yet.
				if( !JumpStart.requestedRoomId )
					return;

				if( JumpStart.personalBrowser )
				{
					var loadingRingElem = document.getElementById("loadingRing");
					if( loadingRingElem )
					{
						loadingRingElem.parentNode.removeChild(loadingRingElem);
					}

					var loadingLogoElem = document.getElementById("loadingLogo");
					if( loadingLogoElem )
					{
						loadingLogoElem.src = "misc/beamnow.png";
					}

					JumpStart.showLoadingMsg("Loading complete.<br /><br /><font style='color: #00ff00; font-size: 30px; background-color: rgba(0, 0, 0, 0.5); padding: 10px; border-radius: 10px;'>Beam this app to an enclosure to begin!</font>");
					return;
				}

			//	console.log(JumpStart.webMode);
				if( JumpStart.webMode )
					document.getElementById("attractImageParent").style.display = "none";
				
				g_crosshair.scale.set(0.0001, 0.0001, 0.0001);

				// first user
				if( g_localUser.firstUser )
				{

				}

				createStartButton();

				// START SIMULATION
				JumpStart.run();
			}

			function onTick()
			{
			//	fireworksLoop();	// Lags game to a consistent 60fps in Altspace.

				if( g_localUser && g_localUser.lookOrigin && g_localUser.lookOrigin.z < 0 && (!g_attract.hasOwnProperty("mirrored") || !g_attract.mirrored) )
				{
					g_attract.style.webkitTransform = "scaleX(-1)";
					g_attract.style.filter = "FlipH";
					g_attract.mirrored = true;
				}
				else if( g_localUser.lookOrigin.z >= 0 && g_attract.hasOwnProperty("mirrored") && g_attract.mirrored )
				{
					g_attract.style.webkitTransform = "none";
					g_attract.style.filter = "none";
					g_attract.mirrored = false;
				}

				// Adjust audio levels
				if( g_myCar && engineLoop )
				{
					var maxDistance = 1000;

					var flexVolume = g_localUser.lookOrigin.distanceTo(g_myCar.position) / maxDistance;
					if( flexVolume > 1.0 )
						flexVolume = 1.0;

					engineLoop.volume = 1.0 - flexVolume;
					engineLoop.volume *= 0.1;
				}
			}
		</script>

		<!-- Custom Object-Level Event Callbacks -->
		<script>
			function giveStar()
			{
				if( !dead )
					return;

				chingLoop.play();

				var carColor = 0;
				if( g_myCar )
					g_myCar.JumpStart.carColor;

				if( carColor == 0 )
					carColor = "";

				setTimeout(function()
				{
					if( !dead )
						return;
										
					var star = JumpStart.spawnInstance("models/LineRacers/star.obj", {"parent": dead});
					star.JumpStart.blocksLOS = false;
					var whole = Math.floor((g_stars.length + g_starGlobalOffsetCount) / 8);

					if( g_stars.length % 8 === 0 )
					{
						g_starSpot = 0;
						g_starRotOffset = 0;
						g_starGlobalOffsetCount = 0;
					}
					else
						g_starSpot++;

					star.rotateY(((Math.PI / -4.0) * whole));

					if( whole > 0 && (g_starSpot === 2 || g_starSpot === 5) )
					{
						g_starRotOffset++;
						g_starGlobalOffsetCount++;
					}

					star.rotateZ((Math.PI / 2.0) + ((Math.PI / -4.0) * g_stars.length) + (g_starRotOffset * (Math.PI / -4.0)));

					star.translateY(20.0);
					star.userData.dustTimer = 0.7 * (g_stars.length / 8.0);

					star.JumpStart.onTick = function()
					{
						this.userData.dustTimer -= 1.0 * g_deltaTime;

						if( this.userData.dustTimer <= 0 )
						{
							this.userData.dustTimer = 0.7 * (g_stars.length / 8.0);
							// Make fairy dust
							var pos = new THREE.Vector3();

							var i, particle;
							for( i = 0; i < 1; i++ )
							{
								particle = JumpStart.spawnInstance("models/LineRacers/gold.obj");
								particle.JumpStart.blocksLOS = false;

								if( !JumpStart.webMode )
								{
									//particle.scale.copy(dead.scale);

									if( dead )
									{
										particle.scale.set(1, 1, 1);
										particle.position.copy(dead.position);
										particle.rotation.copy(dead.rotation);

										particle.translateX(this.position.x * dead.scale.x);
										particle.translateY(this.position.y * dead.scale.y);
										particle.translateZ(this.position.z * dead.scale.z);

										particle.rotation.x += this.rotation.x;
										particle.rotation.y += this.rotation.y;
										particle.rotation.z += this.rotation.z;
									}
									else
									{
										particle.scale.set(1, 1, 1);
										particle.position.copy(this.position);
										particle.rotation.copy(this.rotation);
									}
								}
								else
								{
									pos.setFromMatrixPosition( this.matrixWorld );

									particle.position.copy(pos);
									particle.rotation.copy(this.rotation);
								}

								var scale = Math.random();
								if( scale < 0.5 )
									scale = 0.5;

								particle.scale.multiplyScalar(scale);

								var randoX = 3.0 * Math.random();
								if( Math.random() > 0.5 )
									randoX *= -1.0;

								var randoY = 3.0 * Math.random();
								if( Math.random() > 0.5 )
									randoY *= -1.0;

								var randoZ = 3.0 * Math.random();
								if( Math.random() > 0.5 )
									randoZ *= -1.0;

								particle.translateX(randoX);
								particle.translateY(randoY);
								particle.translateZ(randoZ);

								particle.userData.life = 0.3;
								particle.scale.multiplyScalar(4.0);

								particle.JumpStart.onTick = function()
								{
									if( this.userData.hasOwnProperty("will") )
										this.userData.will -= 1.0 * g_deltaTime;

									if( !this.userData.hasOwnProperty("direction") || this.userData.will <= 0)
									{
										var randoPitch = 1.0 * Math.random();
										if( Math.random() > 0.5 )
											randoPitch *= -1.0;

										var randoYaw = 1.0 * Math.random();
										if( Math.random() > 0.5 )
											randoYaw *= -1.0;

										var randoRoll = 1.0 * Math.random();
										if( Math.random() > 0.5 )
											randoRoll *= -1.0;

										this.userData.direction = new THREE.Vector3(randoPitch, randoYaw, randoRoll);
										this.userData.will = 3.0 * Math.random();
									}

									this.userData.life -= g_deltaTime;
									if( this.userData.life <= 0 )
									{
										//g_scene.remove(this);
										//return;

										this.scale.x -= 1.0 * g_deltaTime;
										this.scale.y -= 1.0 * g_deltaTime;
										this.scale.z -= 1.0 * g_deltaTime;
									}

									this.rotateX(this.userData.direction.x * g_deltaTime);
									this.rotateY(this.userData.direction.y * g_deltaTime);
									this.rotateZ(this.userData.direction.z * g_deltaTime);

									this.translateZ(15.0 * g_deltaTime);
									this.position.y += 10.0 * g_deltaTime;

									if( this.scale.x <= 0.1 )
										g_scene.remove(this);
								};
							}
						}
					};

					g_stars.push(star);
				}, 500);
			}

			function deadSpawn(isLocal, isInitial)
			{
				if( !isLocal )
				{
					JumpStart.playSound("sounds/LineRacers/trumpet", 0.03, false);
/*
					var i;
					for( i = 0; i < g_cars.length; i++ )
					{
						if( g_cars[i].JumpStart.owner === this.JumpStart.owner )
						{
							g_cars[i].userData.dead = true;
							break;
						}
					}
					*/
				}
			}

			function bobLetter()
			{
				var amount = (4.0 * g_deltaTime) * this.userData.bobDirection;
				this.translateY(amount);

				var difference = this.position.y - this.userData.bobOrigin;
				if( (difference > 0 && difference > 2.0) ||
					(difference < 0 && difference < -2.0) )
				{
					if( difference >= 0 )
						this.position.y = this.userData.bobOrigin + 2.0;
					else
						this.position.y = this.userData.bobOrigin - 2.0;

					this.userData.bobDirection *= -1.0;
				}
			}

			function startButtonTick()
			{
				if( !g_crosshair || !g_localUser.lookOrigin )
					return;

				if( !g_localUser.lookHit || !g_localUser.lookHit.object || g_localUser.lookHit.object !== g_floorPlane )
				{
					if( !this.userData.hasOwnProperty("hidden") || !this.userData.hidden)
					{
						this.userData.hidden = true;

						if( !this.userData.hasOwnProperty("originalScale") )
							this.userData.originalScale = new THREE.Vector3();

						this.userData.originalScale.copy(this.scale);
						this.scale.set(0.0001, 0.0001, 0.0001);

						if( g_arrow )
						{
							g_scene.remove(g_arrow);
							g_arrow = null;
						}

						if( g_crash )
						{
							g_scene.remove(g_crash);
							g_crash = null;
						}

						if( g_crashText )
						{
							g_scene.remove(g_crashText);
							g_crashText = null;
						}
					}

					return;
				}

				if( !this.userData.hasOwnProperty("hidden") || this.userData.hidden )
				{
					if( this.userData.hasOwnProperty("originalScale") )
						this.scale.copy(this.userData.originalScale);

					this.userData.hidden = false;

					if( !g_arrow )
					{
						g_arrow = JumpStart.spawnInstance("models/LineRacers/arrow.obj");
						g_arrow.JumpStart.blocksLOS = false;
						g_arrow.JumpStart.onTick = function()
						{
							this.position.copy(g_crosshair.position);
							this.position.y = g_worldOffset.y;

							if( g_myCar )
								this.rotation.copy(g_myCar.rotation);
						};
					}

					g_arrow.position.copy(g_crosshair.position);
					g_arrow.position.y = g_worldOffset.y;

					if( g_myCar )
						g_arrow.rotation.copy(g_myCar.rotation);
				}

				this.position.copy(g_crosshair.position);
				this.lookAt(g_localUser.lookOrigin);
				this.rotation.x = 0;
				this.rotation.z = 0;
			/*
				g_crosshair.userData.hidden = true;

				if( !g_crosshair.userData.hasOwnProperty("originalScale") )
					g_crosshair.userData.originalScale = new THREE.Vector3();

				g_crosshair.userData.originalScale.copy(g_crosshair.scale);
				g_crosshair.scale.set(0.0001, 0.0001, 0.0001);
			*/
			/*
			}
			else if( g_localUser.lookHit && g_localUser.lookHit.object !== g_floorPlane )
			{
				if( g_crosshair.userData.hasOwnProperty("hidden") && g_crosshair.userData.hidden )
				{
					g_crosshair.scale.copy(g_crosshair.userData.originalScale);
					g_crosshair.userData.hidden = false;
					if( g_arrow )
					{
						g_scene.remove(g_arrow);
						g_arrow = null;
					}
				}
			}
			*/
			}


			function createStartButton()
			{
				if( g_crash )
				{
					g_scene.remove(g_crash);
				}

				if( g_crashText )
				{
					g_scene.remove(g_crashText);
				}

				// choose a color
				var colorIndex;
				if( g_cars.length > 0 )
					colorIndex = Number(g_cars[g_cars.length-1].JumpStart.carColor) + 1;
				else
				{
					colorIndex = Math.round(Math.random() * 2.0);
				}

				if( colorIndex > 2 )
					colorIndex = 0;

				var carColor = colorIndex;
				if( carColor == 0 )
					carColor = "";

				startButton = JumpStart.spawnInstance("models/LineRacers/carstand.obj");
				startButton.userData.carColor = colorIndex;
//				startButton.JumpStart.onCursorDown["onCursorDown"] = onCursorDown;
				startButton.JumpStart.onTick["startButtonTick"] = startButtonTick;
				startButton.JumpStart.blocksLOS = false;

				// Make the start button re-position itself IMMIDATELY
				startButtonTick.call(startButton);

				// attach all our parts
				var verts;
				var x;
				for( x in JumpStart.models )
				{
					if( JumpStart.models[x].fileName === "models/LineRacers/carstand_offsets.obj" )
					{
						verts = JumpStart.models[x].object.children[JumpStart.models[x].object.children.length-1].geometry.vertices;
						break;
					}
				}

				var dummyCar = JumpStart.spawnInstance("models/LineRacers/car" + carColor + ".obj", {"parent": startButton});
				//dummyCar.JumpStart.onCursorDown["spawnCar"] = spawnCar;
				dummyCar.position.copy(verts[1]);
				dummyCar.JumpStart.blocksLOS = false;

				var letterR = JumpStart.spawnInstance("models/LineRacers/r.obj", {"parent": startButton});
				//letterR.JumpStart.onCursorDown["spawnCar"] = spawnCar;
				letterR.position.copy(verts[0]);
				letterR.JumpStart.blocksLOS = false;
				letterR.userData.bobDirection = 1.0;
				letterR.userData.bobOrigin = letterR.position.y;
				letterR.JumpStart.onTick = bobLetter;

				var letterA = JumpStart.spawnInstance("models/LineRacers/a.obj", {"parent": startButton});
				//letterA.JumpStart.onCursorDown["spawnCar"] = spawnCar;
				letterA.position.copy(verts[2]);
				letterA.JumpStart.blocksLOS = false;
				letterA.userData.bobDirection = -1.0;
				letterA.userData.bobOrigin = letterA.position.y;
				letterA.JumpStart.onTick = bobLetter;

				var letterC = JumpStart.spawnInstance("models/LineRacers/c.obj", {"parent": startButton});
				//letterC.JumpStart.onCursorDown["spawnCar"] = spawnCar;
				letterC.position.copy(verts[4]);
				letterC.JumpStart.blocksLOS = false;
				letterC.userData.bobDirection = 1.0;
				letterC.userData.bobOrigin = letterC.position.y;
				letterC.JumpStart.onTick = bobLetter;

				var letterE = JumpStart.spawnInstance("models/LineRacers/e.obj", {"parent": startButton});
				//letterE.JumpStart.onCursorDown["spawnCar"] = spawnCar;
				letterE.position.copy(verts[3]);
				letterE.JumpStart.blocksLOS = false;
				letterE.userData.bobDirection = -1.0;
				letterE.userData.bobOrigin = letterE.position.y;
				letterE.JumpStart.onTick = bobLetter;
			}

			function spawnCar()
			{
				if( !startButton )
					return;

				// High scores
				if( !g_highScores )
				{
					g_highScores = JumpStart.spawnInstance("models/LineRacers/star.obj");
					g_highScores.JumpStart.blocksLOS = false;
					g_highScores.scale.set(0.0001, 0.0001, 0.0001);
					g_highScores.position.set(0, -100.0, 0);
					g_highScores.JumpStart.onSpawn["highScores"] = highScores;
					g_highScores.JumpStart.scores = {};

					g_highScores.JumpStart.scores["player1"] = g_localUser.displayName;
					g_highScores.JumpStart.scores["player2"] = "OPEN";
					g_highScores.JumpStart.sync();
				}
				else
				{
					if( g_highScores.JumpStart.scores["player1"] === "OPEN" )
						g_highScores.JumpStart.scores["player1"] = g_localUser.displayName;
					else if( g_highScores.JumpStart.scores["player2"] === "OPEN" )
						g_highScores.JumpStart.scores["player2"] = g_localUser.displayName;
					else
						return;

					g_highScores.JumpStart.sync();
				}

				var colorIndex = startButton.userData.carColor;

				var carColor = colorIndex;
				if( carColor == 0 )
					carColor = "";

				document.getElementById("attractImage").style.display = "none";

				// Start the engine
				JumpStart.playSound("sounds/LineRacers/carstart", 0.2, false);
				setTimeout(function()
				{
					engineLoop = JumpStart.playSound("sounds/LineRacers/idle", 0.1, true);
					engineLoop.flexVolume = 1.0;
				}, 1000)

				// create a car
				var car = JumpStart.spawnInstance("models/LineRacers/body" + carColor + ".obj");
				car.JumpStart.owner = g_localUser.userId;
				car.JumpStart.ownerName = g_localUser.displayName;
				car.position.copy(startButton.position);
				car.rotation.copy(startButton.rotation);
				car.translateZ(-100.0);

				var position = new THREE.Vector3().copy(g_crosshair.position);
				position.y = g_worldOffset.y;
				car.lookAt(position);

				car.JumpStart.onSpawn["initCar"] = initCar;
//				car.userData.dead = false;
				car.JumpStart.owner = g_localUser.userId;
				car.JumpStart.onTick["makeTracks"] = makeTracks;
				car.JumpStart.onNetworkRemoved["carRemoved"] = carRemoved;
				car.JumpStart.lerpSync = true;

				car.JumpStart.carColor = colorIndex;	// auto-synced

				car.JumpStart.sync();
				car.userData.myCar = true;
				car.userData.boost = 0;
				g_myCar = car;

				g_scene.remove(startButton);
				startButton = null;
			}

//			var g_nameSlates = new Array();
			function initCar(isLocal, isInitial)
			{
				if( isInitial )
				{
					JumpStart.unsyncObject(this);
					return;
				}

				car = this;

				//if( isLocal && !car.hasOwnProperty("JumpStart") )
				if( !car.hasOwnProperty("userData" ) || car.userData.isIniting )
					return;

//				if( (car.JumpStart.owner === g_localUser.userId && g_crashText) || !car.hasOwnProperty("userData") || (car.userData.hasOwnProperty("isIniting") && car.userData.isIniting) )
//					return;

				car.userData.isIniting = true;

/*
				var i;
				for( i = 0; i < g_nameSlates.length; i++ )
				{
					if( car.JumpStart.owner === slate[i].userData.owner )
					{
						g_scene.remove(g_nameSlates[i]);
						g_nameSlates.splice(i, 1);
						break;
					}
				}
*/
				var nameSlate = JumpStart.spawnInstance(null);
				nameSlate.userData.owner = car.JumpStart.owner;
				nameSlate.userData.isNameSlate = true;
				nameSlate.JumpStart.blocksLOS = false;
				nameSlate.userData.parentCar = car;

//				g_nameSlates.push(nameSlate);

				var needs = true;
				var i;
				for( i = 0; i < JumpStart.models; i++ )
				{
					if( JumpStart.models[i].fileName === this.JumpStart.ownerName )
					{
						needs = false;
						break;
					}
				}

				if( needs )
				{
					var params = {
						size: 10.0,
						height: 1,
						font: "helvetiker",
						curveSegments: 1
					};

					var geometry;
//					if( JumpStart.webMode )
						geometry = new THREE.TextGeometry(this.JumpStart.ownerName, params);
//					else
//						geometry = new THREE.TextGeometry(this.JumpStart.ownerName);

					var material = new THREE.MeshBasicMaterial({color:'white'});
					var mesh = new THREE.Mesh(geometry, material);

					geometry.computeBoundingBox();

					var displacement = new THREE.Vector3().copy(geometry.boundingBox.max).sub(geometry.boundingBox.min);

					// Make JumpStart think that it is pre-cached.
					JumpStart.models.push({textOffset: displacement, object: mesh, fileName: this.JumpStart.ownerName, batch: "text"});
				}

				var textObject = JumpStart.spawnInstance(this.JumpStart.ownerName);
				textObject.JumpStart.blocksLOS = false;

//				if( !JumpStart.webMode )
//				{
//					textObject.scale.z = 0.1;
//					textObject.scale.multiplyScalar(0.1);
//				}

//				geometry.computeBoundingBox();

				var displacement = new THREE.Vector3().copy(geometry.boundingBox.max).sub(geometry.boundingBox.min);
				displacement.multiply(textObject.scale);
				textObject.position.set(-displacement.x / 2.0, -displacement.y / 2.0, -displacement.z / 2.0);

				nameSlate.add(textObject);

//				nameSlate.up.set( 0, 1, 0 );

				nameSlate.JumpStart.onTick = function()
				{
					var cameraPos = new THREE.Vector3();
					if( JumpStart.webMode )
						cameraPos.copy(g_camera.position);
					else
					{
						var joint = g_localUser.trackingSkeleton.getJoint("Eye");

						// Scale it
						cameraPos.copy(joint.position).multiplyScalar(1/g_worldScale);
					}

					this.position.copy(this.userData.parentCar.position);
					this.translateY(35.0);
					this.lookAt(cameraPos);
				};

				car.userData.nameSlate = nameSlate;

				if( !car.userData.hasOwnProperty("myCar") )
				{
					car.userData.myCar = false;
//					car.userData.dead = false;
				}

				car.JumpStart.blocksLOS = false;
				car.userData.lastSync = 0.0;
				car.userData.lastPos = new THREE.Vector3().copy(car.position);

				// attach all our parts
				var verts;
				var x;
				for( x in JumpStart.models )
				{
					if( JumpStart.models[x].fileName === "models/LineRacers/car_offsets.obj" )
					{
						verts = JumpStart.models[x].object.children[JumpStart.models[x].object.children.length-1].geometry.vertices;
						break;
					}
				}

				var carColor = car.JumpStart.carColor;
				if( carColor == 0 )
					carColor = "";

				var driver = JumpStart.spawnInstance("models/LineRacers/driver" + carColor + ".obj", {"parent": car});
				driver.position.copy(verts[2]);
				driver.JumpStart.blocksLOS = false;
				driver.userData.bobDirection = 1.0;
				driver.userData.bobOrigin = driver.position.y;
				driver.JumpStart.onTick = function()
				{
					var amount = (10.0 * g_deltaTime) * this.userData.bobDirection;
					this.translateY(amount);

					var difference = this.position.y - this.userData.bobOrigin;
					if( (difference > 0 && difference > 1.0) ||
						(difference < 0 ) )
					{
						if( difference >= 0 )
							this.position.y = this.userData.bobOrigin + 1.0;
						else
							this.position.y = this.userData.bobOrigin;

						this.userData.bobDirection *= -1.0;
					}
				};

				var rearRight = JumpStart.spawnInstance("models/LineRacers/rearright" + carColor + ".obj", {"parent": car});
				rearRight.position.copy(verts[0]);
				rearRight.JumpStart.blocksLOS = false;
				rearRight.JumpStart.onTick["tireSpin"] = tireSpin;

				var rearLeft = JumpStart.spawnInstance("models/LineRacers/rearleft" + carColor + ".obj", {"parent": car});
				rearLeft.position.copy(verts[4]);
				rearLeft.JumpStart.blocksLOS = false;
				rearLeft.JumpStart.onTick["tireSpin"] = tireSpin;

				var frontRight = JumpStart.spawnInstance("models/LineRacers/frontright" + carColor + ".obj", {"parent": car});
				frontRight.position.copy(verts[1]);
				frontRight.JumpStart.blocksLOS = false;
				frontRight.JumpStart.onTick["tireSpin"] = tireSpin;

				var frontLeft = JumpStart.spawnInstance("models/LineRacers/frontleft" + carColor + ".obj", {"parent": car});
				frontLeft.position.copy(verts[3]);
				frontLeft.JumpStart.blocksLOS = false;
				frontLeft.JumpStart.onTick["tireSpin"] = tireSpin;

				car.JumpStart.blocksLOS = false;
				car.userData.fadeBegun = false;

				// create a trail
				var trail = JumpStart.spawnInstance("models/LineRacers/pixel" + carColor + ".obj");
				trail.userData.parentCar = car;
				trail.userData.trail = true;
				trail.scale.y = 20.0;
				trail.position.copy(car.position);
				trail.rotation.copy(car.rotation);
				trail.translateZ(-20.0);
				trail.translateY(5.0);
				trail.scale.x = 4.0;
				trail.JumpStart.blocksLOS = false;

				// bookkeeping of car trails
				car.userData.lastPosition = new THREE.Vector3().copy(car.position);
				car.userData.oldestTrail = trail;
				car.userData.activeTrail = trail;
				g_cars.push(car);
			}

			function deadSpin()
			{
				this.rotateY(2.0 * g_deltaTime);
			}

			function deathSpawn()
			{

			}

			function tireSpin()
			{
				var speed = 10.0;
				if( g_myCar && g_myCar.children.indexOf(this) >= 0 )
				{
					if( g_myCar.userData.boost > 0 )
					{
						speed *= 2.0;
					}
				}

				this.rotateX(speed * g_deltaTime);
			}

			function makeTracks()
			{
				if( !this.position.equals(this.userData.lastPos) )
				{
					this.userData.lastPos.copy(this.position);
					this.userData.lastSync = 0;
				}
				else
					this.userData.lastSync += g_deltaTime;
			/*
				if( this.userData.lastSync > 4.0 )
				{
					JumpStart.unsyncObject(this);
					g_scene.remove(this);
					return;
				}
			*/
				var carColor = this.JumpStart.carColor;
				if( carColor == 0 )
					carColor = "";

				if( !this.userData.hasOwnProperty("lastParticle") )
					this.userData.lastParticle = 0.0;

				this.userData.lastParticle -= 1.0 * g_deltaTime;

				if( this.userData.lastParticle <= 0.0 )
				{
					this.userData.lastParticle = 0.04;

					// Make fairy dust
					var i, particle;
					for( i = 0; i < 1; i++ )
					{
						particle = JumpStart.spawnInstance("models/LineRacers/pixel" + carColor + ".obj");
						particle.JumpStart.blocksLOS = false;
						particle.position.copy(this.position);
						particle.rotation.copy(this.rotation);

						particle.translateZ(-20.0);
						particle.translateY(5.0);

						var scale = Math.random();
						if( scale < 0.5 )
							scale = 0.5;

						particle.scale.multiplyScalar(scale);

						var randoX = 3.0 * Math.random();
						if( Math.random() > 0.5 )
							randoX *= -1.0;

						var randoY = 3.0 * Math.random();
						if( Math.random() > 0.5 )
							randoY *= -1.0;

						var randoZ = 3.0 * Math.random();
						if( Math.random() > 0.5 )
							randoZ *= -1.0;

						particle.translateX(randoX);
						particle.translateY(randoY);
						particle.translateZ(randoZ);

						particle.userData.life = 0.3;
						particle.scale.multiplyScalar(4.0);

						particle.JumpStart.onTick = function()
						{
							if( this.userData.hasOwnProperty("will") )
								this.userData.will -= 1.0 * g_deltaTime;

							if( !this.userData.hasOwnProperty("direction") || this.userData.will <= 0)
							{
								var randoPitch = 1.0 * Math.random();
								if( Math.random() > 0.5 )
									randoPitch *= -1.0;

								var randoYaw = 1.0 * Math.random();
								if( Math.random() > 0.5 )
									randoYaw *= -1.0;

								var randoRoll = 1.0 * Math.random();
								if( Math.random() > 0.5 )
									randoRoll *= -1.0;

								this.userData.direction = new THREE.Vector3(randoPitch, randoYaw, randoRoll);
								this.userData.will = 3.0 * Math.random();
							}

							this.userData.life -= g_deltaTime;
							if( this.userData.life <= 0 )
							{
								//g_scene.remove(this);
								//return;

								this.scale.x -= 1.0 * g_deltaTime;
								this.scale.y -= 1.0 * g_deltaTime;
								this.scale.z -= 1.0 * g_deltaTime;
							}

							this.rotateX(this.userData.direction.x * g_deltaTime);
							this.rotateY(this.userData.direction.y * g_deltaTime);
							this.rotateZ(this.userData.direction.z * g_deltaTime);

							this.translateZ(15.0 * g_deltaTime);
							this.position.y += 10.0 * g_deltaTime;

							if( this.scale.x <= 0.1 )
								g_scene.remove(this);
						};
					}
				}

				if( JumpStart.webMode && this.userData.oldestTrail )
				{
					var trail = this.userData.oldestTrail;

					var nextTrail;
					while( typeof trail !== 'undefined' )
					{
						if( !trail.userData.hasOwnProperty("spinMode") || trail.userData.spinMode === true )
						{
							trail.rotateZ(Math.PI);
							nextTrail = trail.userData.nextTrail;
							if( typeof nextTrail !== 'undefined' )
							{
								nextTrail.userData.spinMode = true;
								trail.userData.spinMode = false;
							}
							else
							{
								nextTrail = this.userData.oldestTrail;
								nextTrail.userData.spinMode = true;
								trail.userData.spinmode = false;
							}

							break;
						}

						trail = trail.userData.nextTrail;
					}

			/*
					var foundFlip = false;
					while( trail )
					{
						if( !trail.userData.hasOwnProperty("spinMode") || trail.userData.spinMode )
						{
							trail.userData.spinMode = false;
							trail.rotateY(Math.PI / 2.0);

							if( trail.userData.nextTrail )
								trail.userData.nextTrail.userData.spinMode = true;

							foundFlip = true;
							break;
						}

						trail = trail.userData.nextTrail;
					}

					if( !foundFlip )
						this.userData.oldestTrail.spinMode = true;
					*/
				}

				if( this.userData.myCar )
				{
					// Drive towards the crosshair.
					var position = new THREE.Vector3().copy(g_crosshair.position);
					position.y = g_worldOffset.y;

					//position.multiplyScalar(1/g_worldScale);

					var driveDistance = position.distanceTo(this.position);

					if( driveDistance < 25.0 )
					{
//						if( !dead )
							localCarCrash.call(this);
					}
					else
					{
						this.lookAt(position);

						var speed = driveDistance;
						if( speed < 30 )
							speed = 0;
						else if( speed > 100 )
							speed = 100;

						this.userData.boost -= g_deltaTime;

						if( this.userData.boost > 0 )
						{
							speed = 150;
							//speed *= 1.5;

							if( this.userData.hasOwnProperty("lastBoostTime") )
								this.userData.lastBoostTime -= g_deltaTime;

							if( this.userData.boost && (!this.userData.hasOwnProperty("lastBoostTime") || this.userData.lastBoostTime <= 0) )
							{
								//this.userData.lastBoostTime = 0.2;
								this.userData.lastBoostTime = 0.2 / this.userData.boost;

								var i, particle;
								for( i = 0; i < 16; i++ )
								{
									particle = JumpStart.spawnInstance("models/LineRacers/pixel" + carColor + ".obj");
									particle.JumpStart.blocksLOS = false;
									particle.position.copy(this.position);
									particle.rotation.copy(this.rotation);

									var scale = Math.random();
									scale *= 0.7;

									if( scale < 0.5 )
										scale = 0.5;

									particle.scale.multiplyScalar(scale);

									var randoX = 3.0 * Math.random();
									if( Math.random() > 0.5 )
										randoX *= -1.0;

									var randoY = 3.0 * Math.random();
									if( Math.random() > 0.5 )
										randoY *= -1.0;

									var randoZ = 3.0 * Math.random();
									if( Math.random() > 0.5 )
										randoZ *= -1.0;

									if( randoY > 0 )
										randoY *= -1.0;

									particle.translateX(randoX);
									particle.translateY(randoY);
									particle.translateZ(-15.0);

									var matrix = new THREE.Matrix4().copy(this.matrix);
									matrix.multiply(new THREE.Matrix4().makeTranslation(0, 0, -15.0));

									particle.lookAt(new THREE.Vector3().setFromMatrixPosition(matrix));

									particle.userData.shock = 2.0;
									particle.userData.life = 0.05;
									particle.scale.multiplyScalar(10.0);

									particle.JumpStart.onTick = function()
									{
										particle.userData.shock -= g_deltaTime;

										if( particle.userData.shock <= 0.0 )
										{
											if( this.userData.hasOwnProperty("will") )
												this.userData.will -= 1.0 * g_deltaTime;

											if( !this.userData.hasOwnProperty("direction") || this.userData.will <= 0)
											{
												var randoPitch = Math.PI * Math.random();
												if( Math.random() > 0.5 )
													randoPitch *= -1.0;

												var randoYaw = Math.PI * Math.random();
												if( Math.random() > 0.5 )
													randoYaw *= -1.0;

												var randoRoll = Math.PI * Math.random();
												if( Math.random() > 0.5 )
													randoRoll *= -1.0;

												this.userData.direction = new THREE.Vector3(randoPitch, randoYaw, randoRoll);
												this.userData.will = 3.0 * Math.random();
											}

											this.userData.life -= g_deltaTime;
											if( this.userData.life <= 0 )
											{
												// Leave this in will make it scale down x2 as fast after life is gone.
												this.scale.x -= 6.0 * g_deltaTime;
												this.scale.y -= 6.0 * g_deltaTime;
												this.scale.z -= 6.0 * g_deltaTime;
											}

											this.rotateX(this.userData.direction.x * g_deltaTime);
											this.rotateY(this.userData.direction.y * g_deltaTime);
											this.rotateZ(this.userData.direction.z * g_deltaTime);

											this.translateZ(15.0 * g_deltaTime);
											this.position.y += 10.0 * g_deltaTime;
										}
										else
										{
											this.translateZ(200.0 * g_deltaTime);
										}

										this.scale.x -= 6.0 * g_deltaTime;
										this.scale.y -= 6.0 * g_deltaTime;
										this.scale.z -= 6.0 * g_deltaTime;

										if( this.scale.x <= 0.1 )
											g_scene.remove(this);
									};
								}
							}
						}
						else
						{
							this.userData.boost = 0;
							this.userData.lastBoostTime = 0;
						}

						this.translateZ(speed * g_deltaTime);

						// Test for collisions
						var x, car, barrier, testPoint, dist;
						for( x in g_cars )
						{
							car = g_cars[x];
							barrier = car.userData.oldestTrail;

							while( barrier )
							{
								// ignore the active trail
								if( !barrier || barrier === this.userData.activeTrail || barrier.userData.nextTrail === this.userData.activeTrail )
									break;
								
								// only care about barriers we can hit
								if( typeof barrier.userData.rayToNext === 'undefined' || barrier.position.distanceTo(this.position) > barrier.scale.z / 2.0 )
								{
									barrier = barrier.userData.nextTrail;
									continue;
								}

								testPoint = barrier.userData.rayToNext.closestPointToPoint(this.position);
								dist = testPoint.distanceTo(this.position);

								if( dist < 10.0 )
								{
//									if( !dead )
//									{
										localCarCrash.call(this);
//									}
								}

								barrier = barrier.userData.nextTrail;
							}
						}
					}
				}
				else
				{
					doScaleLerp.call(this);
					doRotationLerp.call(this);
					doPositionLerp.call(this);
				}

				// Keep the active trail aligned.
				var trail = this.userData.activeTrail;
				trail.position.copy(this.position);
				trail.rotation.copy(this.rotation);
				trail.translateZ(-20.0);
				trail.translateY(5.0);
				trail.lookAt(this.userData.lastPosition);
				trail.rotateZ(Math.PI);
				trail.scale.z = trail.position.distanceTo(this.userData.lastPosition) * 2.0;

				// Create a new trail object every 10.0 meters.
				if( trail.scale.z > 20.0 )
				{
					if( this.userData.myCar && g_arrow && g_myCar )
					{
						if( !this.userData.hasOwnProperty("lastTracerElapsed") )
							this.userData.lastTracerElapsed = 0.0;

						this.userData.lastTracerElapsed += g_deltaTime;

						if( this.userData.lastTracerElapsed >= 0.1 )
						{
							this.userData.lastTracerElapsed = 0.0;

							// Fire a new tracer
							var tracer = JumpStart.spawnInstance("models/LineRacers/gold.obj", {"parent": g_myCar});
							tracer.userData.isParticle = true;
							tracer.JumpStart.hasLOS = false;
				//			tracer.scale.set(0.5, 0.5, 0.5);

							tracer.JumpStart.onTick = function()
							{
								if( !g_myCar || !g_arrow )
									return;

								this.translateZ(300.0 * g_deltaTime);
								if( this.position.length() >= g_myCar.position.distanceTo(g_arrow.position) - 20 )
								{
									g_myCar.remove(this);
									return;
								}

								// Make fairy dust
								var pos = new THREE.Vector3();

								if( !this.userData.hasOwnProperty("lastParticle") )
									this.userData.lastParticle = 0.0;

								this.userData.lastParticle -= 1.0 * g_deltaTime;

								if( this.userData.lastParticle <= 0.0 )
								{
									this.userData.lastParticle = 0.02;

									var i, particle;
									for( i = 0; i < 1; i++ )
									{
										particle = JumpStart.spawnInstance("models/LineRacers/gold.obj", {"parent": g_myCar});
										particle.userData.isParticle = true;
										particle.JumpStart.blocksLOS = false;

										particle.position.copy(this.position);
										particle.rotation.copy(this.rotation);
										particle.scale.set(1, 1, 1);

										var scale = Math.random();
										if( scale < 0.5 )
											scale = 0.5;

										particle.scale.multiplyScalar(scale);

										var randoX = 3.0 * Math.random();
										if( Math.random() > 0.5 )
											randoX *= -1.0;

										var randoY = 3.0 * Math.random();
										if( Math.random() > 0.5 )
											randoY *= -1.0;

										var randoZ = 3.0 * Math.random();
										if( Math.random() > 0.5 )
											randoZ *= -1.0;

										particle.translateX(randoX);
				//						particle.translateY(randoY);
										particle.translateZ(randoZ);

										particle.userData.life = 0.3;
										particle.scale.multiplyScalar(4.0);

										particle.JumpStart.onTick = function()
										{
											if( this.userData.hasOwnProperty("will") )
												this.userData.will -= 1.0 * g_deltaTime;

											if( !this.userData.hasOwnProperty("direction") || this.userData.will <= 0)
											{
												var randoPitch = 1.0 * Math.random();
												if( Math.random() > 0.5 )
													randoPitch *= -1.0;

												var randoYaw = 1.0 * Math.random();
												if( Math.random() > 0.5 )
													randoYaw *= -1.0;

												var randoRoll = 1.0 * Math.random();
												if( Math.random() > 0.5 )
													randoRoll *= -1.0;

												this.userData.direction = new THREE.Vector3(randoPitch, randoYaw, randoRoll);
												this.userData.will = 3.0 * Math.random();
											}

											this.userData.life -= g_deltaTime;

											if( g_myCar && g_arrow && this.position.length() > g_arrow.position.distanceTo(g_myCar.position) - 15.0 )
											{
											//	this.scale.x += 2.0 * g_deltaTime;
											//	this.scale.y += 2.0 * g_deltaTime;
											//	this.scale.z += 2.0 * g_deltaTime;
												g_myCar.remove(this);
												return;
											}

											if( this.userData.life <= 0 )
											{
												//g_scene.remove(this);
												//return;

												this.scale.x -= 4.0 * g_deltaTime;
												this.scale.y -= 4.0 * g_deltaTime;
												this.scale.z -= 4.0 * g_deltaTime;
											}

				//							this.rotateX(this.userData.direction.x * g_deltaTime);
											this.rotateY(this.userData.direction.y * g_deltaTime);
				//							this.rotateZ(this.userData.direction.z * g_deltaTime);

											this.translateZ(15.0 * g_deltaTime);
				//							this.position.y += 10.0 * g_deltaTime;

											if( g_myCar && this.scale.x <= 0.1 )
												g_myCar.remove(this);
										};
									}
								}
							};
						}
					}

					// Spawn the object
					var nextTrail = JumpStart.spawnInstance("models/LineRacers/pixel" + carColor + ".obj");
					nextTrail.userData.parentCar = this;
					nextTrail.userData.trail = true;
					nextTrail.scale.y = 20.0;
					nextTrail.position.copy(this.position);
					nextTrail.rotation.copy(this.rotation);
					nextTrail.translateZ(-20.0);
					nextTrail.translateY(5.0);
					nextTrail.scale.x = 4.0;
					nextTrail.JumpStart.blocksLOS = false;

					// update the linked list
					trail.userData.nextTrail = nextTrail;

					var direction = new THREE.Vector3().copy(trail.position).sub(nextTrail.position);
					trail.userData.rayToNext = new THREE.Ray(trail.position, direction.normalize());

					// bookkeeping of car trails
					this.userData.lastPosition.copy(trail.position);
					this.userData.activeTrail = nextTrail;

					if( !this.userData.fadeBegun )
					{
						// start the trail fade
						this.userData.fadeBegun = true;
						trail.JumpStart.onTick["smartFade"] = smartFade;
					}

					if( this.userData.myCar )
						this.JumpStart.sync();
				}
			}

			function localCarCrash()
			{
				var carColor = this.JumpStart.carColor;
				if( carColor == 0 )
					carColor = "";

				if( engineLoop )
				{
					JumpStart.killSound(engineLoop);
					engineLoop = null;
				}

				if( g_arrow )
				{
					g_scene.remove(g_arrow);
					g_arrow = null;

					g_crash = JumpStart.spawnInstance("models/LineRacers/dont.obj");
					g_crash.JumpStart.hasLOS = false;
					g_crash.userData.rotDirection = 1;
					g_crash.userData.rotAmount = 0;

					g_crashText = JumpStart.spawnInstance("models/LineRacers/crashtext.obj");
					g_crashText.JumpStart.onTick = function()
					{
						if( g_crash )
							this.position.copy(g_crash.position);
					};

					g_crashText.position.copy(g_crash.position);

					g_crash.userData.waitTime = 4.0;
					g_crash.JumpStart.onTick = function()
					{
						this.userData.waitTime -= g_deltaTime;

						if( this.userData.waitTime <= 0 )
						{
							createStartButton();
							return;
						}

						var rot = 1.0 * this.userData.rotDirection * g_deltaTime;

						this.userData.rotAmount += rot;
						if( this.userData.rotAmount > Math.PI / 4.0 )
						{
							this.userData.rotAmount = Math.PI / 4.0;
							this.userData.rotDirection = -1;
						}
						else if( this.userData.rotAmount < -Math.PI / 4.0 )
						{
							this.userData.rotAmount = -Math.PI / 4.0;
							this.userData.rotDirection = 1;
						}
						else
						{
							this.rotateY(rot);
						}

						this.position.copy(g_crosshair.position);
						this.position.y = g_worldOffset.y;
					};

					g_crash.position.copy(g_crosshair.position);
					g_crash.position.y = g_worldOffset.y;
					g_crash.position.y += 20.0;
				}

//				chingLoop = JumpStart.playSound("sounds/LineRacers/ching", 1.0, false);
				JumpStart.playSound("sounds/LineRacers/crash", 0.2, false);
//				dead = JumpStart.spawnInstance("models/LineRacers/dead" + carColor + ".obj");
//				g_myCar.userData.dead = true;

				/*
				dead.JumpStart.owner = g_localUser.userId;
				dead.JumpStart.blocksLOS = false;
				dead.JumpStart.onSpawn["deadSpawn"] = deadSpawn;
				dead.position.copy(this.position);
				dead.rotation.copy(this.rotation);
				dead.position.y += 80.0;

				giveStar();
				starHandle = setInterval(giveStar, 1500);

				dead.scale.multiplyScalar(2.0);

				dead.JumpStart.onTick["deadSpin"] = deadSpin;

				dead.JumpStart.sync();

				delete this.JumpStart.onTick;
				this.JumpStart.sync();
				*/
				JumpStart.unsyncObject(g_myCar);
				// FIXME: JumpStart has an issue that makes clearing the tick listener from here
				// NOT work unless network is enabled!!
			}

			function smartFade()
			{
				var factor = 1.0;

//				if( this.userData.parentCar.userData.dead )
//					factor = 10.0;

				this.scale.z -= 150.0 * g_deltaTime;

				if( this.scale.z <= 0 )
				{
					this.scale.z = 0;

					var ending = false;
					if( this.userData.hasOwnProperty('nextTrail') )
						this.userData.nextTrail.JumpStart.onTick["smartFade"] = smartFade;
					else
						return;
						//ending = true;

/*
					// Update the car's oldestTrail
					var x, car, body, y, part, clone, randoX, randoY, randoZ;
					for( x in g_cars )
					{
						car = g_cars[x];
						if( car.userData.oldestTrail === this )
						{
							car.userData.oldestTrail = this.userData.nextTrail;

							if( ending && car.userData.myCar )
							{
								// LAST TRAIL HAS BEEN REMOVED
								JumpStart.unsyncObject(car);

								//var startButton = JumpStart.spawnInstance("models/LineRacers/carstand.obj");
								//startButton.JumpStart.onCursorDown["spawnCar"] = spawnCar;
								createStartButton();
							}

							break;
						}
					}
					*/


					g_scene.remove(this);
				}
			}

			function highScores()
			{
				g_highScores = this;
				g_highScores.JumpStart.addDataListener("scores", function(oldValue, value, isLocal) {
/*
					var scoresArray = new Array();
					var i;
					for( i in value )
					{
						scoresArray.push(value[i]);
					}

					scoresArray.sort(function(a, b) { return (a.high - b.high) * (-1); });
					*/
					var table = document.getElementById("highscores");

					// Remove all old rows
					var targetRows = table.getElementsByTagName("tr");
					while( targetRows.length > 0 )
					{
						table.removeChild(targetRows[0]);
						targetRows = table.getElementsByTagName("tr");
					}

					// Add new rows
					var x, playerScore, row, nameCol, scoreCol;
					for( x in value )
					{
						playerScore = value[x];
						row = document.createElement("tr");

						nameCol = document.createElement("td");
						if( x === "player1" )
							nameCol.innerHTML = "Player 1: ";
						else
							nameCol.innerHTML = "Player 2: ";

						scoreCol = document.createElement("td");

						var stuff = playerScore;
						if( stuff === "OPEN" )
							stuff = "<font style='color: orange;'>" + stuff + "</font>";

						scoreCol.innerHTML = stuff;

						row.appendChild(nameCol);
						row.appendChild(scoreCol);
						table.appendChild(row);
					}
				});
			}

			function carRemoved()
			{
//				var index = g_nameSlates.indexOf(this.userData.nameSlate);

				g_scene.remove(this.userData.nameSlate);

//				if( index >= 0 )
//					g_nameSlates.splice(index, 1);

				var car = this;
				g_cars.splice(g_cars.indexOf(car), 1);

				var carColor = car.JumpStart.carColor;
				if( carColor == 0 )
					carColor = "";

				// Stop the sound
				if( chingLoop )
				{
					JumpStart.killSound(chingLoop);
					chingLoop = null;
				}

				// Start the new sounds
				//JumpStart.playSound("sounds/LineRacers/trumpet", 0.5, false);
				g_starGlobalOffsetCount = 0;

				JumpStart.playSound("sounds/LineRacers/explosion", 0.2, false);

				if( this.userData.myCar )
				{
					var needsSync = true;
					if( g_highScores.JumpStart.scores["player1"] === g_localUser.displayName )
						g_highScores.JumpStart.scores["player1"] = "OPEN";
					else if( g_highScores.JumpStart.scores["player2"] === g_localUser.displayName )
						g_highScores.JumpStart.scores["player2"] = "OPEN";
					else
						needsSync = false;

					if( needsSync )
						g_highScores.JumpStart.sync();

//					JumpStart.playSound("sounds/LineRacers/cashout", 1.0, false);
/*
					// High scores
					if( !g_highScores )
					{
						g_highScores = JumpStart.spawnInstance("models/LineRacers/star.obj");
						g_highScores.JumpStart.blocksLOS = false;
						g_highScores.scale.set(0.0001, 0.0001, 0.0001);
						g_highScores.position.set(0, -100.0, 0);
						g_highScores.JumpStart.onSpawn["highScores"] = highScores;
						g_highScores.JumpStart.scores = {};

						var score = g_highScores.JumpStart.scores[g_localUser.userId] = {"displayName": g_localUser.displayName, "high": g_stars.length};

						g_highScores.JumpStart.sync();
					}
					else
					{
						var needsSync = false;

						var score;
						if( g_highScores.JumpStart.scores.hasOwnProperty(g_localUser.userId) )
						{
							score = g_highScores.JumpStart.scores[g_localUser.userId];

							if( g_stars.length > score.high )
							{
								score.high = g_stars.length;
								needsSync = true;
							}
						}
						else
						{
							g_highScores.JumpStart.scores[g_localUser.userId] = {"displayName": g_localUser.displayName, "high": g_stars.length};
							needsSync = true;
						}

						if( needsSync )
							g_highScores.JumpStart.sync();
					}
					*/
				}

				// Make a visual fire ball
				var pos;
				if( !JumpStart.webMode )
					pos = new THREE.Vector3();

				if( this.userData.myCar )
				{
					/*
					var x, star;
					for( x in g_stars )
					{
						star = g_stars[x];
						
						if( !JumpStart.webMode )
							pos.copy(star.position);

						THREE.SceneUtils.detach(star, dead, g_scene);
						star.userData.lifeLeft = 150;

						if( !JumpStart.webMode )
						{
							star.scale.copy(dead.scale);
							star.position.copy(dead.position);
							star.rotation.copy(dead.rotation);

							star.translateX(pos.x);
							star.translateY(pos.y);
							star.translateZ(pos.z);
						}

						star.JumpStart.onTick["deathWatch"] = function()
						{
							this.userData.lifeLeft--;

							if( this.userData.lifeLeft <= 0 )
							{
								g_stars.splice( g_stars.indexOf(star), 1 );
								g_scene.remove(this);
							}
						};
						star.JumpStart.applyForce(new THREE.Vector3().copy(star.position).sub(dead.position).multiplyScalar(0.15));
					}
					*/
				}

				var explosion = JumpStart.spawnInstance("models/LineRacers/explosion.obj");
				explosion.scale.set(0.001, 0.001, 0.001);
				explosion.userData.scaleSize = 0.001;
				explosion.userData.scaleDirection = 1;
				explosion.position.copy(car.position).y += 15.0;
				explosion.JumpStart.blocksLOS = false;

				explosion.JumpStart.onTick = function()
				{
					if( this.userData.scaleDirection === 1 )
					{
						this.userData.scaleSize += 5.0 * g_deltaTime;

						if( this.userData.scaleSize >= 1.0 )
							this.userData.scaleDirection = -1;
					}
					else
					{
						this.userData.scaleSize -= 4.0 * g_deltaTime;

						if( this.userData.scaleSize <= 0.001 )
						{
							g_scene.remove(this);
							return;
						}
					}

					this.scale.set(this.userData.scaleSize, this.userData.scaleSize, this.userData.scaleSize);
					this.rotateY(15.0 * g_deltaTime);
					this.rotateX(20.0 * g_deltaTime);
				};

				// Add a body to explode
				var body = JumpStart.spawnInstance("models/LineRacers/body" + carColor + ".obj", {"parent": car});

				var y, part, clone, randoY, randoX, randoZ, force;
				for( y in car.children )
				{
					part = car.children[y];

					if( !part.hasOwnProperty("JumpStart") || part.hasOwnProperty("isParticle") || part.userData.hasOwnProperty("isNameSlate") )
						continue;

					clone = JumpStart.spawnInstance(part.JumpStart.modelFile);
					clone.position.copy(new THREE.Vector3().setFromMatrixPosition(part.matrixWorld));
					clone.JumpStart.blocksLOS = false;

					randoY = 0.0;
					if( clone.position.equals(new THREE.Vector3(0, 0, 0)) )
					{
						randoY = 30.0;
						clone.position.copy(car.position);

						if( !JumpStart.webMode )
						{
							// FIXME: Why is 10 the magic number, i wonder?
							clone.position.y += 10.0;
						}
					}
					else if( !JumpStart.webMode )
						clone.position.multiplyScalar(1/g_worldScale);

					clone.quaternion.copy(part.getWorldQuaternion());

					randoX = 20.0 * Math.random();
					if( Math.random() > 0.5 )
						randoX *= -1.0;

					randoZ = 20.0 * Math.random();
					if( Math.random() > 0.5 )
						randoZ *= -1.0;

					// The main body should go nearly straight up
					if( JumpStart.webMode && clone.position.equals(car.position) )
					{
						randoX *= 0.3;
						randoZ *= 0.3;
					}

					force = new THREE.Vector3().copy(part.position);

					clone.JumpStart.applyForce(new THREE.Vector3(force.x + randoX, (force.y * 5.0) + randoY, force.z + randoZ).multiplyScalar(0.25));

					// The main body shouldn't spin so much.
					if( randoY !== 0.0 )
						clone.JumpStart.freefallRot.multiplyScalar(0.3);

					clone.JumpStart.onTick = function()
					{
						if( this.position.y < g_worldOffset.y )
						{
							this.position.y = g_worldOffset.y;
							this.JumpStart.physicsState = 0;

							this.userData.lifeSpan = 4.0;
							this.JumpStart.onTick = function()
							{
								this.userData.lifeSpan -= g_deltaTime;

								if( this.userData.lifeSpan <= 0 )
								{
									this.userData.lifeSpan = 0;
									g_scene.remove(this);
								}
							};
						}
					};
				}

				var explosionLook = new THREE.Vector3().copy(explosion.rotation);

				// Particles
				var i, particle;
				for( i = 0; i < 16; i++ )
				{
					particle = JumpStart.spawnInstance("models/LineRacers/pixel" + carColor + ".obj");
					particle.JumpStart.blocksLOS = false;
					particle.position.copy(explosion.position);
					particle.rotation.copy(explosion.rotation);

					var scale = Math.random();
					if( scale < 0.5 )
						scale = 0.5;

					particle.scale.multiplyScalar(scale);

					var randoX = 3.0 * Math.random();
					if( Math.random() > 0.5 )
						randoX *= -1.0;

					var randoY = 3.0 * Math.random();
					if( Math.random() > 0.5 )
						randoY *= -1.0;

			//		if( randoY < 0 )
			//			randoY = 0;

					var randoZ = 3.0 * Math.random();
					if( Math.random() > 0.5 )
						randoZ *= -1.0;

					particle.translateX(randoX);

					if( randoY > 0 )
						particle.translateY(randoY);

					particle.translateZ(randoZ);

					explosion.lookAt(particle.position);
					particle.rotation.copy(explosion.rotation);

					particle.userData.shock = 2.0;
					particle.userData.life = 0.2;
					particle.scale.multiplyScalar(10.0);

					particle.JumpStart.onTick = function()
					{
						particle.userData.shock -= g_deltaTime;

						if( particle.userData.shock <= 0.0 )
						{
							if( this.userData.hasOwnProperty("will") )
								this.userData.will -= 1.0 * g_deltaTime;

							if( !this.userData.hasOwnProperty("direction") || this.userData.will <= 0)
							{
								var randoPitch = Math.PI * Math.random();
								if( Math.random() > 0.5 )
									randoPitch *= -1.0;

								var randoYaw = Math.PI * Math.random();
								if( Math.random() > 0.5 )
									randoYaw *= -1.0;

								var randoRoll = Math.PI * Math.random();
								if( Math.random() > 0.5 )
									randoRoll *= -1.0;

								this.userData.direction = new THREE.Vector3(randoPitch, randoYaw, randoRoll);
								this.userData.will = 3.0 * Math.random();
							}

							this.userData.life -= g_deltaTime;
							if( this.userData.life <= 0 )
							{
								//g_scene.remove(this);
			//					this.JumpStart.onTick = function()
			//					{
									this.scale.x -= 1.0 * g_deltaTime;
									this.scale.y -= 1.0 * g_deltaTime;
									this.scale.z -= 1.0 * g_deltaTime;

			//					};

			//					return;
							}

							this.rotateX(this.userData.direction.x * g_deltaTime);
							this.rotateY(this.userData.direction.y * g_deltaTime);
							this.rotateZ(this.userData.direction.z * g_deltaTime);

							this.translateZ(15.0 * g_deltaTime);
							this.position.y += 10.0 * g_deltaTime;

							if( this.scale.x <= 0.1 )
								g_scene.remove(this);
						}
						else
						{
							this.translateZ(200.0 * g_deltaTime);
						}
					};
				}

				explosion.rotation.copy(explosionLook);

//				if( car.userData.myCar )
//				{
//					g_myCar = null;
/*
					if( dead )
					{
						JumpStart.unsyncObject(dead);
						g_scene.remove(dead);
						dead = null;
						clearInterval(starHandle);
					}
					*/
//				}

				// Remove all trails associated with this car

				var deathList = new Array();

				var i, child;
				for( i = 0; i < g_scene.children.length; i++ )
				{
					child = g_scene.children[i];

					if( child.userData.hasOwnProperty("trail") && child.userData.parentCar.JumpStart.owner === car.JumpStart.owner )
					{
						deathList.push(child);
					}
				}

				for( i = 0; i < deathList.length; i++ )
					g_scene.remove(deathList[i]);

				if( deathList.indexOf(car.userData.activeTrail) < 0 )
					g_scene.remove(car.userData.activeTrail);

				g_scene.remove(car);

				if( car.userData.myCar )
					g_myCar = null;
			}

			function doScaleLerp()
			{
				if( this.userData.hasOwnProperty("targetScaleLerp") && this.userData.targetScaleLerp < 1.0 )
				{
					this.userData.targetScaleLerp += (1.0/this.userData.targetScaleLerpTime) * g_deltaTime;

					var justFinished = false;
					if( this.userData.targetScaleLerp >= 1.0 )
					{
						this.userData.targetScaleLerp = 1.0;
						justFinished = true;
					}

					this.scale.lerpVectors(this.userData.targetScaleOriginal, this.userData.targetScale, this.userData.targetScaleLerp);

					if( justFinished )
					{
						if( this.userData.hasOwnProperty("targetScaleAnim") && this.userData.targetScaleAnim.length > 0 )
						{
							var nextTarget = this.userData.targetScaleAnim.shift();
							if( !nextTarget.targetScaleOriginal )
								nextTarget.targetScaleOriginal = new THREE.Vector3().copy(this.scale);

							// Set our new targets.
							this.userData.targetScale.copy(nextTarget.targetScale);
							this.userData.targetScaleOriginal.copy(nextTarget.targetScaleOriginal);
							this.userData.targetScaleLerp = nextTarget.targetScaleLerp;
							this.userData.targetScaleLerpTime = nextTarget.targetScaleLerpTime;
						}
					}
				}
			}

			function doPositionLerp()
			{
				if( this.userData.hasOwnProperty("targetPosLerp") && this.userData.targetPosLerp < 1.0 )
				{
					this.userData.targetPosLerp += (1.0/this.userData.targetPosLerpTime) * g_deltaTime;

					var justFinished = false;
					if( this.userData.targetPosLerp >= 1.0 )
					{
						this.userData.targetPosLerp = 1.0;
						justFinished = true;
					}

					this.position.lerpVectors(this.userData.targetPosOriginal, this.userData.targetPos, this.userData.targetPosLerp);

					if( justFinished )
					{
						if( typeof this.userData.targetPosCallback === "function" )
							this.userData.targetPosCallback.call(this);

						this.userData.targetPosCallback = null;

						if( this.userData.hasOwnProperty("targetPosAnim") && this.userData.targetPosAnim.length > 0 )
						{
							var nextTarget = this.userData.targetPosAnim.shift();
							if( !nextTarget.targetPosOriginal )
								nextTarget.targetPosOriginal = new THREE.Vector3().copy(this.position);

							// Set our new targets.
							this.userData.targetPos.copy(nextTarget.targetPos);
							this.userData.targetPosOriginal.copy(nextTarget.targetPosOriginal);
							this.userData.targetPosLerp = nextTarget.targetPosLerp;
							this.userData.targetPosLerpTime = nextTarget.targetPosLerpTime;
							if( typeof nextTarget.targetPosCallback === "function" )
								this.userData.targetPosCallback = nextTarget.targetPosCallback;
						}
					}
				}
			}

			function doRotationLerp()
			{
				if( this.userData.hasOwnProperty("targetRotLerp") && this.userData.targetRotLerp < 1.0 )
				{
					this.userData.targetRotLerp += (1.0/this.userData.targetRotLerpTime) * g_deltaTime;

					var justFinished = false;
					if( this.userData.targetRotLerp >= 1.0 )
					{
						this.userData.targetRotLerp = 1.0;
						justFinished = true;
					}

					var myQuaternionA = new THREE.Quaternion().setFromEuler(new THREE.Euler().setFromVector3(this.userData.targetRotOriginal, 'XYZ'));
					var myQuaternionB = new THREE.Quaternion().setFromEuler(new THREE.Euler().setFromVector3(this.userData.targetRot, 'XYZ'));

					myQuaternionA.slerp(myQuaternionB, this.userData.targetRotLerp);
					this.quaternion.copy(myQuaternionA);
			//		this.rotation.lerpVectors(this.userData.targetRotOriginal, this.userData.targetRot, this.userData.targetRotLerp);

					if( justFinished )
					{
						if( this.userData.hasOwnProperty("targetRotAnim") && this.userData.targetRotAnim.length > 0 )
						{
							var nextTarget = this.userData.targetRotAnim.shift();
							if( !nextTarget.targetRotOriginal )
								nextTarget.targetRotOriginal = new THREE.Vector3().copy(this.rotation);

							// Set our new targets.
							this.userData.targetRot.copy(nextTarget.targetRot);
							this.userData.targetRotOriginal.copy(nextTarget.targetRotOriginal);
							this.userData.targetRotLerp = nextTarget.targetRotLerp;
							this.userData.targetRotLerpTime = nextTarget.targetRotLerpTime;
						}
					}
				}
			}
		</script>
	</body>
</html>