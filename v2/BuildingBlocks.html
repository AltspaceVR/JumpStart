<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Building Blocks</title>
		<script src="engine/misc/JumpStart.js"></script>

		<script>
			// Setup JumpStart
			var options = {
				"appID": "BuildingBlocks",
				"scaleWithEnclosure": true,
				"sceneScale": 2.0,
				"debug":
				{
					"showCursorPlanes": false
				}
			};
			loadJumpStart(options);

			// Global variables that BuildingBlocks will use
			var blockModels = ["models/bricks", "models/cube", "models/dirt", "models/grass", "models/jewel"];
			var g_placeholder = null;

			function createBlock()
			{
				var cage = jumpStart.scene.getObjectByName("cage");
				var sampleBlock = cage.userData.sampleBlock;

				var block = jumpStart.spawnInstance(sampleBlock.modelFile);
				block.position.copy(cage.position);
				block.blocksLOS = true;
				block.addEventListener("cursorup", createBlock);
				block.addEventListener("spawn", blockSpawn);
				block.addEventListener("remove", blockRemove);
				block.sync();
				block.scale.copy(cage.userData.sampleBlock.scale);
			}

			function blockRemove()
			{
				function spawnDebris(parent, translation)
				{
					var direction = new THREE.Vector3();
					var rotation = new THREE.Vector3((Math.PI / 2.0) * Math.random(), (Math.PI / 2.0) * Math.random(), (Math.PI / 2.0) * Math.random());;

					var debris = jumpStart.spawnInstance(parent.modelFile);
					debris.scale.multiplyScalar(0.3);
					debris.position.copy(parent.position);
					debris.translateX(translation.x);
					debris.translateZ(translation.y);
					debris.translateY(translation.z);
					direction.copy(debris.position).sub(parent.position).y += 12.0;

					// Aiming error
					var maxError = 100.0;
					var axis = ["x", "y", "z"];
					var x;
					for( x in axis )
					{
						direction[x] += Math.random() * maxError;

						if( Math.random() > 0.5 )
							direction[x] *= -1.0;
					}

					scalar = 0.8 * Math.random();
					if( scalar > maxScalar )
						scalar = maxScalar;
					else if( scalar > minScalar )
						scalar = minScalar;

					direction.multiplyScalar(scalar);
					applyForce(debris, direction, rotation);

					debris.userData.life = 1.0;
					debris.addEventListener("tick", function()
					{
						if( this.userData.life > 0 )
							this.userData.life -= g_deltaTime;
						else
						{
							this.scale.x -= 1.0 * g_deltaTime;
							this.scale.y -= 1.0 * g_deltaTime;
							this.scale.z -= 1.0 * g_deltaTime;

							if( this.scale.x <= 0.0001 )
								jumpStart.removeInstance(this);
						}
					});
				}

				//var direction = new THREE.Vector3();//(0, 5.0, 0);

				var maxScalar = 0.6;
				var minScalar = 0.3;
				var radius = this.boundingSphere.radius;
				var count = 0;
				var i, debrisQ1, debrisQ2, debrisQ3, debrisQ4, scalar;
				for( i = 0; i < 2; i++, count++ )
				{
					if( count % 2 )
						continue;

					spawnDebris(this, new THREE.Vector3(radius / 5.0, -radius / 5.0, radius / 5.0 * (i) ? 1.0 : -1.0));
					spawnDebris(this, new THREE.Vector3(-radius / 5.0, -radius / 5.0, radius / 5.0 * (i * -1.0)));
					spawnDebris(this, new THREE.Vector3(-radius / 5.0, radius / 5.0, radius / 5.0 * (i * -1.0)));
					spawnDebris(this, new THREE.Vector3(radius / 5.0, radius / 5.0, radius / 5.0 * (i * -1.0)));
				}
			}

			function blockSpawn(isInitialSync)
			{
				this.userData.isBlock = true;

				if( isInitialSync )
					return;

				g_placeholder.scale.set(1, 1, 1);
				g_placeholder.position.copy(this.position);

				// Continue spawning "this" block
				this.userData.maxScale = 1.0;
				this.userData.minScale = 0.8;
				this.userData.scaleDirection = 0;

				if( this.ownerID !== jumpStart.localUser.userID )
					this.scale.set(0.0001, 0.0001, 0.0001);

				// Local listener
				this.addEventListener("tick", function()
				{
					var amount;
					if( !this.userData.scaleDirection )
					{
						amount = this.scale.x + (2.0 * g_deltaTime);
						if( amount >= this.userData.maxScale )
						{
							amount = this.userData.maxScale;
							this.removeEventListener("tick", arguments.callee);

							// Hide the placeholder
							g_placeholder.scale.set(0.0001, 0.0001, 0.0001);
						}
					}
					else
					{
						amount = this.scale.x + (1.0 * g_deltaTime) * this.userData.scaleDirection;
						if( amount < this.userData.minScale )
						{
							amount = this.userData.minScale;
							this.userData.scaleDirection *= -1.0;
						}
						else if( amount > this.userData.maxScale )
						{
							amount = this.userData.maxScale;
							this.userData.scaleDirection *= -1.0;
						}
					}

					this.scale.set(amount, amount, amount);
				});
			}

			// Precache our models
			jumpStart.addEventListener("precache", function()
			{
				var models = [
					"models/bricks",
					"models/cube",
					"models/cube_cage",
					"models/dirt",
					"models/grass",
					"models/jewel",
					"models/placeholder"
				];

				jumpStart.loadModels(models).then( function()
				{
					jumpStart.doneCaching();
				});

				return false;
			});

			// Spawn local objects
			jumpStart.addEventListener("ready", function()
			{
				jumpStart.world.position.x += 200.0;
				// So that we can raycast against the floor of the enclosure.
				var floorBoundary = jumpStart.enclosureBoundary("floor");
				floorBoundary.addEventListener("cursorup", function() { createBlock(); });

				// Make the floor 40% larger to avoid Altspace from thinking mouse clicks are not captured along the edges
				floorBoundary.scale.multiplyScalar(1.4);

				var cage = jumpStart.spawnInstance("models/cube_cage");
				cage.name = "cage";
				cage.addEventListener("spawn", function()
				{
					this.userData.sampleBlock = createSampleBlock(blockModels[0]);
				});
				cage.addEventListener("tick", function()
				{
					if( jumpStart.localUser.cursorHit )
					{
						var radius = this.userData.sampleBlock.boundingSphere.radius;
						var pos = jumpStart.localUser.cursorHit.scaledPoint.clone();
						var object = jumpStart.localUser.cursorHit.object;

						if( !!object && object.userData.isBlock )
						{
							var offset = jumpStart.localUser.cursorHit.face.normal.clone().normalize().multiplyScalar(radius / 5.0);
							pos.add(offset);
						}

						var farEnoughAway = true;
						var x;
						for( x in pos )
						{
							pos[x] = (pos[x] < -0.01) ? pos[x] - (pos[x] % (radius / 1)) - radius / 2 : pos[x] = pos[x] - (pos[x] % (radius / 1)) + radius / 2;
						}

						var insideOfEnclosure = jumpStart.isWorldPosInsideOfEnclosure(pos);

						// Make sure the cage isn't too close to the player
						if( insideOfEnclosure )
						{
							this.position.copy(pos);

							var cursorPos = jumpStart.world.worldToLocal(jumpStart.cursorRay.origin.clone());
							if( cursorPos.distanceTo(pos) < 40.0 )
								farEnoughAway = false;
						}

						if( (!insideOfEnclosure || !farEnoughAway) && !!!this.userData.hidden )
						{
							this.userData.hidden = true;
							this.scale.set(0.0001, 0.0001, 0.0001);
						}
						else if( insideOfEnclosure && farEnoughAway && !!this.userData.hidden )
						{
							this.userData.hidden = false;
							this.scale.set(1, 1, 1);
						}
					}
					else if( !!!this.userData.hidden )
					{
						this.userData.hidden = true;
						this.scale.set(0.0001, 0.0001, 0.0001);
					}
				});

				// Spawn an invisible block placeholder
				g_placeholder = jumpStart.spawnInstance("models/placeholder");
				g_placeholder.blocksLOS = true;
				g_placeholder.userData.isBlock = true;
				g_placeholder.addEventListener("cursorup", createBlock);
				jumpStart.makeMaterialsInvisible(g_placeholder);

				// true	: SYNCHRONOUS
				// false: ASYNCHRONOUS (must call JumpStart.run)
				return true;
			});

			function createSampleBlock(modelFile)
			{
				var cage = jumpStart.scene.getObjectByName("cage");

				var sampleBlock = jumpStart.spawnInstance(modelFile, {"parent": cage});
				sampleBlock.userData.maxScale = 0.8;
				sampleBlock.userData.minScale = 0.5;
				sampleBlock.userData.scaleDirection = 1.0;
				sampleBlock.scale.set(sampleBlock.userData.minScale, sampleBlock.userData.minScale, sampleBlock.userData.minScale);

				// Local listener
				sampleBlock.addEventListener("tick", function()
				{
					var amount = this.scale.x + (0.3 * g_deltaTime) * this.userData.scaleDirection;
					if( amount < this.userData.minScale )
					{
						amount = this.userData.minScale;
						this.userData.scaleDirection *= -1.0;
					}
					else if( amount > this.userData.maxScale )
					{
						amount = this.userData.maxScale;
						this.userData.scaleDirection *= -1.0;
					}

					this.scale.set(amount, amount, amount);
				});

				return sampleBlock;
			}

			jumpStart.addEventListener("keydown", function(e)
			{
				if( e.keyCode == 0 || e.keyCode == 32 )
					deleteBlock();
				else if( e.keyCode == 88 )
					cycleBlock(1);
				else if( e.keyCode == 90 )
					cycleBlock(-1);
			}, false);

			function cycleBlock(direction)
			{
				var cage = jumpStart.scene.getObjectByName("cage");
				var sampleBlock = cage.userData.sampleBlock;

				var index = blockModels.indexOf(sampleBlock.modelFile) + direction;
				if( index >= blockModels.length )
					index = 0;
				else if( index < 0 )
					index = blockModels.length - 1;

				var scale = sampleBlock.scale.clone();
				var scaleDirection = sampleBlock.userData.scaleDirection;
				jumpStart.removeInstance(sampleBlock);

				sampleBlock = createSampleBlock(blockModels[index]);
				sampleBlock.scale.copy(scale);
				sampleBlock.userData.scaleDirection = scaleDirection;

				cage.userData.sampleBlock = sampleBlock;
			}

			function deleteBlock()
			{
				if( jumpStart.localUser.cursorHit )
				{
					var block = jumpStart.localUser.cursorHit.object;

					if( block.userData.isBlock )
						jumpStart.removeInstance(block);
				}
			}

			function applyForce(block, force, rotation)
			{
				if( !!!block.userData.physics )
					makePhysics(block);

				block.syncData.physics.force.copy(force);
				block.syncData.physics.rotation.copy(rotation);
				block.userData.physics.velocity.copy(block.syncData.physics.force);
			}

			function makePhysics(block, doSync)
			{
				block.syncData.physics = {
					"force": new THREE.Vector3(),
					"rotation": new THREE.Vector3()
				};

				block.userData.physics = {
					"velocity": new THREE.Vector3()
				};

				block.addEventListener("tick", physicsTick);
				block.addEventListener("spawn", physicsSpawn);
			}

			function physicsSpawn()
			{
				this.userData.physics = {
					"velocity": new THREE.Vector3(this.syncData.physics.force.x, this.syncData.physics.force.y, this.syncData.physics.force.z)
				};
			}

			function physicsTick()
			{
				this.userData.physics.velocity.y -= 9.8 * g_deltaTime;

				// Terminal velocity because we have no air drag
				var termVel = 50.0;
				var velLen = this.userData.physics.velocity.length();
				if( velLen > termVel )
					this.userData.physics.velocity.multiplyScalar(0.9);

				// Update the rotation
				this.rotateX((this.syncData.physics.rotation.x * 5.0) * g_deltaTime);
				this.rotateY((this.syncData.physics.rotation.y * 5.0) * g_deltaTime);
				this.rotateZ((this.syncData.physics.rotation.z * 5.0) * g_deltaTime);

				// Bounce us off of walls
				var maximums = {
					"x": jumpStart.enclosure.innerWidth / 2.0,
					"y": (jumpStart.enclosure.innerHeight / 2.0),
					"z": jumpStart.enclosure.innerDepth / 2.0
				};

				this.updateMatrixWorld();
				var pos = new THREE.Vector3().setFromMatrixPosition(this.matrixWorld);
				var deltaPos = this.userData.physics.velocity.clone().multiplyScalar(g_deltaTime * 100.0)
				pos.add(deltaPos);

				var x, max;
				for( x in maximums )
				{
					if( pos[x] > maximums[x] )
					{
						pos[x] = maximums[x];
						this.userData.physics.velocity[x] *= -1.0;
					}
					else if( pos[x] < -maximums[x] )
					{
						pos[x] = -maximums[x];
						this.userData.physics.velocity[x] *= -1.0;
					}
				}

				pos.multiplyScalar(1 / jumpStart.options.sceneScale);
				pos.sub(jumpStart.world.position);

				this.position.copy(pos);
				/*
				if( !(state & 0x4) )
					sceneObject.position.add(deltaPos);
				else
				{
					sceneObject.translateX(deltaPos.x);
					sceneObject.translateY(deltaPos.y);
					sceneObject.translateZ(deltaPos.z);
				}
				*/
			}
		</script>
	</head>

	<body>
	</body>
</html>